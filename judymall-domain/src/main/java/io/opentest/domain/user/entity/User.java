package io.opentest.domain.user.entity;

import com.fasterxml.jackson.annotation.JsonManagedReference;
import com.google.common.collect.Sets;
import io.opentest.domain.user.converters.PasswordEncodeConverter;
import io.opentest.domain.user.converters.ProviderConverter;
import io.opentest.domain.user.enums.Provider;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import org.hibernate.annotations.GenericGenerator;

import java.io.Serializable;
import java.util.Collection;
import java.util.UUID;
import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Convert;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.ForeignKey;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.ManyToMany;
import javax.persistence.OneToOne;
import javax.persistence.Table;
import javax.persistence.UniqueConstraint;

@NoArgsConstructor
@RequiredArgsConstructor(staticName = "on")
@AllArgsConstructor(staticName = "of")
@Setter
@Getter
@Builder
@Table (
        name = "T_USER",
        uniqueConstraints = {@UniqueConstraint(name = "UK_USER_1", columnNames = {"loginId", "enabled"})}
        /* uniqueConstraints = {
                @UniqueConstraint(name = "UNIQ_IDENTITY_IN_USER", columnNames = {"identity"}),
                @UniqueConstraint(name = "UNIQ_USERNAME__PROVIDER_IN_USER", columnNames = {"username", "provider"})
        }*/
)
//@AttributeOverride(name = "seq", column = @Column(name = "user_seq"))
@Entity
public class User implements Serializable {

    @Id
    @Column(columnDefinition = "UUID")
    @GeneratedValue(generator = "uuid")
    @GenericGenerator(name = "uuid", strategy = "org.hibernate.id.UUIDGenerator")
    private UUID id;

    //, columnDefinition = "VARCHAR(30) COMMENT '아이디'"
    @NonNull
    @Column(nullable = false, length = 30)
    private String loginId;

    //, columnDefinition = "VARCHAR(255) COMMENT '비밀번호'"
    @Convert(converter = PasswordEncodeConverter.class)
    @Column(updatable = true, nullable = true, length = 255)
    private String password;

    //, columnDefinition = "VARCHAR(5) COMMENT '정보 제공처'"
    @NonNull
    @Convert(converter = ProviderConverter.class)
    @Column(updatable = false, nullable = false, length = 5)
    private Provider provider;

    private String enabled;

    // ----- Relationships -----

    /**
     * <h2>다대다관계 매핑.</h2>
     * <ul>
     *  <li>타입은 List보다 Set을 사용하자. 쿼리확인해보자.</li>
     *  <li>M:N은 M:1, 1:N으로 해소하자.</li>
     * </ul>
     *
     * @see <a href="https://www.baeldung.com/jpa-many-to-many">Many-To-Many Relationship in JPA</a>
     * @see <a href="https://happyer16.tistory.com/entry/Spring-JPA-다대다-설정-및-주의-Many-To-Many">대대다매핑은 Set을 사용</a>
     */
    @Default
    @ManyToMany(fetch = FetchType.EAGER, cascade = CascadeType.ALL)
    @JoinTable (
            name = "T_USER_ROLE",
            joinColumns = @JoinColumn(name = "user_id", referencedColumnName = "id", foreignKey = @ForeignKey(name = "FK_USER_ROLE_3")),
            inverseJoinColumns = @JoinColumn(name = "role_id", referencedColumnName = "id", foreignKey = @ForeignKey(name = "FK_USER_ROLE_2")),
            foreignKey = @ForeignKey(name = "FK_USER_ROLE_1")
    )
    private Collection<Role> roles = Sets.newHashSet();

    /*
    public void bind(Role role) {
        roles.add(role);
    }

    public void binds(Collection<Role> roles) {
        roles.addAll(roles);
    }

    @JsonManagedReference
    @OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL, orphanRemoval = true, mappedBy = "host")
    @JoinColumn(name = "user_seq", referencedColumnName = "seq")
    private Profile profile;

    public void bind(Profile profile) {
        setProfile(profile);
        profile.setHost(this);
    }
    */
}
