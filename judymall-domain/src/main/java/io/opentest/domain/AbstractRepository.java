/*
 * Copyright 2019. OPENTEST. All rights reserved.
 */

package io.opentest.domain;

import lombok.extern.slf4j.Slf4j;

import java.io.Serializable;
import java.util.Optional;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.transaction.Transactional;

/**
 * Abstract Jpa Repository.
 *
 * @author andromediano
 * @param <E> Entity
 * @param <K> Id
 */
@Slf4j
public abstract class AbstractRepository<E extends Serializable, K> implements GenericRepository<E, K> {

    private Class<E> clazz;

    /**
     * PersistenceContextType.
     *
     * <p>PersistenceContextType.EXTENDED로 설정하면 OpenEntityManagerInViewFilter를 사용하지 않아도 된다.
     * 그런데 PostgreSQL에서 @ManyToOne 관계에 있는 엔티티 저장시 org.springframework.transaction.TransactionSystemException 발생.
     * 그래서 기본값인 PersistenceContextType.TRANSACTION 으로 설정 하였다.</p>
     * <dl>
     * <dt><a href="https://jcp.org/aboutJava/communityprocess/final/jsr220/index.html">jsr220</a> 에서 다음 섹션을 확인 해 보자.</dt>
     * <dd>
     *  <ul>
     *      <li>5.6.1 Container-managed Transaction-scoped Persistence Context</li>
     *      <li>5.6.2 Container-managed Extended Persistence Context</li>
     *  </ul>
     * </dd>
     * </dl>
     *
     * @see <a href="http://stackoverflow.com/questions/2547817/what-is-the-difference-between-transaction-scoped-persistence-context-and-extend">What is the difference between Transaction-scoped Persistence context and Extended Persistence context?</a>
     */
    @PersistenceContext//(type = PersistenceContextType.TRANSACTION)
    private EntityManager em;

    protected void setClazz(final Class<E> clazzToSet) {
        this.clazz = clazzToSet;
    }

    public EntityManager entityManager() {
        return em;
    }

    @Transactional
    public E save(final E entity) {
        em.persist(entity);
        return entity;
    }

    @Transactional
    public E update(final E entity) {
        em.merge(entity);
        return entity;
    }

    @Transactional
    public void remove(final E entity) {
        em.remove(entity);
    }

    @Transactional
    public void remove(final K id) {
        em.remove(findOne(id));
    }

    public Optional<E> findOne(final K id) {
        return Optional.ofNullable(em.find(clazz, id));
    }

    public E find(final K id) {
        return em.find(clazz, id);
    }
}
